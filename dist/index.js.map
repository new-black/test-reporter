{"version":3,"file":"index.js","mappings":";AAAA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://test-check/webpack/runtime/compat","../webpack://test-check/./lib/main.js"],"sourcesContent":["\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst core = __importStar(require(\"@actions/core\"));\r\nconst github = __importStar(require(\"@actions/github\"));\r\nconst local_file_provider_js_1 = require(\"./input-providers/local-file-provider.js\");\r\nconst get_annotations_js_1 = require(\"./report/get-annotations.js\");\r\nconst get_report_js_1 = require(\"./report/get-report.js\");\r\nconst dart_json_parser_js_1 = require(\"./parsers/dart-json/dart-json-parser.js\");\r\nconst dotnet_trx_parser_js_1 = require(\"./parsers/dotnet-trx/dotnet-trx-parser.js\");\r\nconst java_junit_parser_js_1 = require(\"./parsers/java-junit/java-junit-parser.js\");\r\nconst jest_junit_parser_js_1 = require(\"./parsers/jest-junit/jest-junit-parser.js\");\r\nconst mocha_json_parser_js_1 = require(\"./parsers/mocha-json/mocha-json-parser.js\");\r\nconst path_utils_js_1 = require(\"./utils/path-utils.js\");\r\nconst github_utils_js_1 = require(\"./utils/github-utils.js\");\r\nconst markdown_utils_js_1 = require(\"./utils/markdown-utils.js\");\r\nconst webhook_1 = require(\"@slack/webhook\");\r\nconst fs_1 = __importDefault(require(\"fs\"));\r\n//import fetch from 'node-fetch'\r\nconst bent_1 = __importDefault(require(\"bent\"));\r\nconst process_1 = require(\"process\");\r\nasync function main() {\r\n    try {\r\n        const testReporter = new TestReporter();\r\n        await testReporter.run();\r\n    }\r\n    catch (error) {\r\n        core.setFailed(error.message);\r\n    }\r\n}\r\nclass TestReporter {\r\n    constructor() {\r\n        this.artifact = core.getInput('artifact', { required: false });\r\n        this.name = core.getInput('name', { required: true });\r\n        this.path = core.getInput('path', { required: true });\r\n        this.pathReplaceBackslashes = core.getInput('path-replace-backslashes', { required: false }) === 'true';\r\n        this.reporter = core.getInput('reporter', { required: true });\r\n        this.listSuites = core.getInput('list-suites', { required: true });\r\n        this.listTests = core.getInput('list-tests', { required: true });\r\n        this.maxAnnotations = parseInt(core.getInput('max-annotations', { required: true }));\r\n        this.failOnError = core.getInput('fail-on-error', { required: true }) === 'true';\r\n        this.workDirInput = core.getInput('working-directory', { required: false });\r\n        this.onlySummary = core.getInput('only-summary', { required: false }) === 'true';\r\n        this.token = core.getInput('token', { required: true });\r\n        this.slackWebhook = core.getInput('slack-url', { required: false });\r\n        this.resultsEndpoint = core.getInput('test-results-endpoint', { required: true });\r\n        this.resultsEndpointSecret = core.getInput('test-results-endpoint-secret', { required: true });\r\n        this.context = (0, github_utils_js_1.getCheckRunContext)();\r\n        this.octokit = github.getOctokit(this.token);\r\n        if (this.listSuites !== 'all' && this.listSuites !== 'failed') {\r\n            core.setFailed(`Input parameter 'list-suites' has invalid value`);\r\n            return;\r\n        }\r\n        if (this.listTests !== 'all' && this.listTests !== 'failed' && this.listTests !== 'none') {\r\n            core.setFailed(`Input parameter 'list-tests' has invalid value`);\r\n            return;\r\n        }\r\n        if (isNaN(this.maxAnnotations) || this.maxAnnotations < 0 || this.maxAnnotations > 50) {\r\n            core.setFailed(`Input parameter 'max-annotations' has invalid value`);\r\n            return;\r\n        }\r\n    }\r\n    async run() {\r\n        if (this.workDirInput) {\r\n            core.info(`Changing directory to '${this.workDirInput}'`);\r\n            process.chdir(this.workDirInput);\r\n        }\r\n        core.info(`Check runs will be created with SHA=${this.context.sha}`);\r\n        // Split path pattern by ',' and optionally convert all backslashes to forward slashes\r\n        // fast-glob (micromatch) always interprets backslashes as escape characters instead of directory separators\r\n        const pathsList = this.path.split(',');\r\n        const pattern = this.pathReplaceBackslashes ? pathsList.map(path_utils_js_1.normalizeFilePath) : pathsList;\r\n        const inputProvider = new local_file_provider_js_1.LocalFileProvider(this.name, pattern);\r\n        const parseErrors = this.maxAnnotations > 0;\r\n        const trackedFiles = await inputProvider.listTrackedFiles();\r\n        const workDir = this.artifact ? undefined : (0, path_utils_js_1.normalizeDirPath)(process.cwd(), true);\r\n        core.info(`Found ${trackedFiles.length} files tracked by GitHub`);\r\n        const options = {\r\n            workDir,\r\n            trackedFiles,\r\n            parseErrors\r\n        };\r\n        core.info(`Using test report parser '${this.reporter}'`);\r\n        const parser = this.getParser(this.reporter, options);\r\n        const results = [];\r\n        const input = await inputProvider.load();\r\n        try {\r\n            const readStream = input.trxZip.toBuffer();\r\n            const version = fs_1.default.existsSync('src/EVA.TestSuite.Core/bin/Release/version.txt')\r\n                ? fs_1.default.readFileSync('src/EVA.TestSuite.Core/bin/Release/version.txt').toString()\r\n                : null;\r\n            const commitID = fs_1.default.existsSync('src/EVA.TestSuite.Core/bin/Release/commit.txt')\r\n                ? fs_1.default.readFileSync('src/EVA.TestSuite.Core/bin/Release/commit.txt').toString()\r\n                : null;\r\n            core.info(`Using EVA version ${version}, commit ${commitID}, current directory: ${(0, process_1.cwd)()}`);\r\n            const post = (0, bent_1.default)(this.resultsEndpoint, 'POST', {}, 200);\r\n            await post(`TestResults?Secret=${this.resultsEndpointSecret}${version ? '&EVAVersion=' + version : ''}${commitID ? '&EVACommitID=' + commitID : ''}`, readStream);\r\n            core.info(`Uploaded TRX files`);\r\n        }\r\n        catch (ex) {\r\n            core.warning(`Could not upload TRX ZIP file: ${ex}`);\r\n        }\r\n        for (const [reportName, files] of Object.entries(input.reports)) {\r\n            try {\r\n                core.startGroup(`Creating test report ${reportName}`);\r\n                const tr = await this.createReport(parser, reportName, files);\r\n                results.push(...tr);\r\n            }\r\n            finally {\r\n                core.endGroup();\r\n            }\r\n        }\r\n        const isFailed = results.some(tr => tr.result === 'failed');\r\n        const conclusion = isFailed ? 'failure' : 'success';\r\n        const passed = results.reduce((sum, tr) => sum + tr.passed, 0);\r\n        const failed = results.reduce((sum, tr) => sum + tr.failed, 0);\r\n        const skipped = results.reduce((sum, tr) => sum + tr.skipped, 0);\r\n        const time = results.reduce((sum, tr) => sum + tr.time, 0);\r\n        core.setOutput('conclusion', conclusion);\r\n        core.setOutput('passed', passed);\r\n        core.setOutput('failed', failed);\r\n        core.setOutput('skipped', skipped);\r\n        core.setOutput('time', time);\r\n        if (this.failOnError && isFailed) {\r\n            core.setFailed(`Failed test were found and 'fail-on-error' option is set to ${this.failOnError}`);\r\n            return;\r\n        }\r\n        if (results.length === 0) {\r\n            core.setFailed(`No test report files were found`);\r\n            return;\r\n        }\r\n    }\r\n    async createReport(parser, name, files) {\r\n        if (files.length === 0) {\r\n            core.warning(`No file matches path ${this.path}`);\r\n            return [];\r\n        }\r\n        const results = [];\r\n        for (const { file, content } of files) {\r\n            core.info(`Processing test results from ${file}`);\r\n            const tr = await parser.parse(file, content);\r\n            results.push(tr);\r\n        }\r\n        core.info(`Creating check run ${name}`);\r\n        const createResp = await this.octokit.rest.checks.create({\r\n            head_sha: this.context.sha,\r\n            name,\r\n            status: 'in_progress',\r\n            output: {\r\n                title: name,\r\n                summary: ''\r\n            },\r\n            ...github.context.repo\r\n        });\r\n        core.info('Creating report summary');\r\n        const { listSuites, listTests, onlySummary } = this;\r\n        const baseUrl = createResp.data.html_url || '';\r\n        const summary = (0, get_report_js_1.getReport)(results, { listSuites, listTests, baseUrl, onlySummary });\r\n        core.info('Creating annotations');\r\n        const annotations = (0, get_annotations_js_1.getAnnotations)(results, this.maxAnnotations);\r\n        const isFailed = results.some(tr => tr.result === 'failed');\r\n        const conclusion = isFailed ? 'failure' : 'success';\r\n        const icon = isFailed ? markdown_utils_js_1.Icon.fail : markdown_utils_js_1.Icon.success;\r\n        core.info(`Updating check run conclusion (${conclusion}) and output`);\r\n        const resp = await this.octokit.rest.checks.update({\r\n            check_run_id: createResp.data.id,\r\n            conclusion,\r\n            status: 'completed',\r\n            output: {\r\n                title: `${name} ${icon}`,\r\n                summary,\r\n                annotations\r\n            },\r\n            ...github.context.repo\r\n        });\r\n        core.info(`Check run create response: ${resp.status}`);\r\n        core.info(`Check run URL: ${resp.data.url}`);\r\n        core.info(`Check run HTML: ${resp.data.html_url}`);\r\n        core.info(`Check run details: ${resp.data.details_url}`);\r\n        if (this.slackWebhook && this.context.branch === 'master') {\r\n            const webhook = new webhook_1.IncomingWebhook(this.slackWebhook);\r\n            const passed = results.reduce((sum, tr) => sum + tr.passed, 0);\r\n            const skipped = results.reduce((sum, tr) => sum + tr.skipped, 0);\r\n            const failed = results.reduce((sum, tr) => sum + tr.failed, 0);\r\n            const req = {\r\n                blocks: [\r\n                    {\r\n                        type: 'section',\r\n                        text: {\r\n                            type: 'mrkdwn',\r\n                            text: `:large_green_circle: ${passed} :large_orange_circle: ${skipped} :red_circle: ${failed} <${resp.data.html_url}|(view)>`\r\n                        }\r\n                    }\r\n                ]\r\n            };\r\n            results.map((tr, runIndex) => {\r\n                if (tr.failed === 0)\r\n                    return;\r\n                const runName = tr.path.slice(0, tr.path.indexOf('/TestResults/'));\r\n                req.blocks.push({\r\n                    type: 'section',\r\n                    text: {\r\n                        type: 'mrkdwn',\r\n                        text: `:red_circle: ${tr.failed} in <${resp.data.html_url}#r${runIndex}|${runName}>`\r\n                    }\r\n                });\r\n            });\r\n            await webhook.send(req);\r\n        }\r\n        return results;\r\n    }\r\n    getParser(reporter, options) {\r\n        switch (reporter) {\r\n            case 'dart-json':\r\n                return new dart_json_parser_js_1.DartJsonParser(options, 'dart');\r\n            case 'dotnet-trx':\r\n                return new dotnet_trx_parser_js_1.DotnetTrxParser(options);\r\n            case 'flutter-json':\r\n                return new dart_json_parser_js_1.DartJsonParser(options, 'flutter');\r\n            case 'java-junit':\r\n                return new java_junit_parser_js_1.JavaJunitParser(options);\r\n            case 'jest-junit':\r\n                return new jest_junit_parser_js_1.JestJunitParser(options);\r\n            case 'mocha-json':\r\n                return new mocha_json_parser_js_1.MochaJsonParser(options);\r\n            default:\r\n                throw new Error(`Input variable 'reporter' is set to invalid value '${reporter}'`);\r\n        }\r\n    }\r\n}\r\nmain();\r\n"],"names":[],"sourceRoot":""}